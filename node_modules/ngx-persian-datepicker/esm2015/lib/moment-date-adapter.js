/**
 * @fileoverview added by tsickle
 * Generated from: lib/moment-date-adapter.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Inject, Injectable, LOCALE_ID, Optional } from '@angular/core';
import { DateAdapter } from '@angular/material';
import { JalaliMomentDateAdapter } from './jalali-date-adapter';
import { extendObject } from './object-extend';
import { Subject } from 'rxjs';
import { BehaviorSubject } from 'rxjs';
// TODO(mmalerba): Remove when we no longer support safari 9.
/**
 * Whether the browser supports the Intl API.
 * @type {?}
 */
const SUPPORTS_INTL_API = typeof Intl != 'undefined';
/**
 * The default month names to use if Intl API is not available.
 * @type {?}
 */
const DEFAULT_MONTH_NAMES = {
    'long': [
        'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September',
        'October', 'November', 'December'
    ],
    'short': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    'narrow': ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D']
};
const ɵ0 = /**
 * @param {?} i
 * @return {?}
 */
i => String(i + 1);
/**
 * The default date names to use if Intl API is not available.
 * @type {?}
 */
const DEFAULT_DATE_NAMES = range(31, (ɵ0));
/**
 * The default day of the week names to use if Intl API is not available.
 * @type {?}
 */
const DEFAULT_DAY_OF_WEEK_NAMES = {
    'long': ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    'short': ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    'narrow': ['S', 'M', 'T', 'W', 'T', 'F', 'S']
};
/**
 * Creates an array and fills it with values.
 * @template T
 * @param {?} length
 * @param {?} valueFunction
 * @return {?}
 */
function range(length, valueFunction) {
    /** @type {?} */
    const valuesArray = Array(length);
    for (let i = 0; i < length; i++) {
        valuesArray[i] = valueFunction(i);
    }
    return valuesArray;
}
/**
 * Adapts the native JS Date for use with cdk-based components that work with dates.
 */
export class NativeDateAdapter extends DateAdapter {
    /**
     * @param {?} localeId
     */
    constructor(localeId) {
        super();
        this.lang = 'fa';
        this.langSubject = new Subject();
        this.JDateAdapter = new JalaliMomentDateAdapter('fa');
        /**
         * Whether to use `timeZone: 'utc'` with `Intl.DateTimeFormat` when formatting dates.
         * Without this `Intl.DateTimeFormat` sometimes chooses the wrong timeZone, which can throw off
         * the result. (e.g. in the en-US locale `new Date(1800, 7, 14).toLocaleDateString()`
         * will produce `'8/13/1800'`.
         */
        this.useUtcForDisplay = true;
        super.setLocale(localeId);
    }
    /**
     * @return {?}
     */
    invalid() {
        return new Date();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    toIso8601(date) {
        return 'hi';
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    sameDate(a, b) {
        return false;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    setLocale(v) {
        super.setLocale(v);
        if (this.lang != 'fa') {
            this.lang = 'fa';
            this.langSubject.next('fa');
        }
        else {
            this.lang = 'en';
            this.langSubject.next('en');
        }
    }
    /**
     * @return {?}
     */
    getLang() {
        return this.langSubject;
    }
    /**
     * @return {?}
     */
    changeLocale() {
        if (this.lang != 'fa') {
            this.setLocale('fa');
        }
        else {
            this.setLocale('en');
        }
    }
    /**
     * @param {?} date
     * @param {?=} force
     * @return {?}
     */
    getYear(date, force) {
        if (this.lang == 'fa' && !force) {
            return this.JDateAdapter.getYear((/** @type {?} */ (date)));
        }
        if (date._d) {
            return date._d.getFullYear();
        }
        if (!date.getFullYear) {
            debugger;
        }
        return date.getFullYear();
    }
    /**
     * @param {?} date
     * @param {?=} force
     * @return {?}
     */
    getMonth(date, force) {
        if (this.lang == 'fa' && !force) {
            return this.JDateAdapter.getMonth((/** @type {?} */ (date)));
        }
        if (date._d) {
            return date._d.getMonth();
        }
        return date.getMonth();
    }
    /**
     * @param {?} date
     * @param {?=} force
     * @return {?}
     */
    getDate(date, force) {
        if (this.lang == 'fa' && !force) {
            return this.JDateAdapter.getDate((/** @type {?} */ (date)));
        }
        if (date._d) {
            return date._d.getDate();
        }
        return date.getDate();
    }
    /**
     * @param {?} date
     * @param {?=} force
     * @return {?}
     */
    getDayOfWeek(date, force) {
        if (this.lang == 'fa' && !force) {
            return this.JDateAdapter.getDayOfWeek((/** @type {?} */ (date)));
        }
        return date.getDay();
    }
    /**
     * @param {?} style
     * @param {?=} force
     * @return {?}
     */
    getMonthNames(style, force) {
        if (this.lang == 'fa' && !force) {
            return this.JDateAdapter.getMonthNames(style);
        }
        if (SUPPORTS_INTL_API) {
            /** @type {?} */
            const dtf = new Intl.DateTimeFormat(this.locale, { month: style });
            return range(12, (/**
             * @param {?} i
             * @return {?}
             */
            i => this._stripDirectionalityCharacters(dtf.format(new Date(2017, i, 1)))));
        }
        return DEFAULT_MONTH_NAMES[style];
    }
    /**
     * @param {?=} force
     * @return {?}
     */
    getDateNames(force) {
        if (this.lang == 'fa' && !force) {
            return this.JDateAdapter.getDateNames();
        }
        if (SUPPORTS_INTL_API) {
            /** @type {?} */
            const dtf = new Intl.DateTimeFormat(this.locale, { day: 'numeric' });
            return range(31, (/**
             * @param {?} i
             * @return {?}
             */
            i => this._stripDirectionalityCharacters(dtf.format(new Date(2017, 0, i + 1)))));
        }
        return DEFAULT_DATE_NAMES;
    }
    /**
     * @param {?} style
     * @param {?=} force
     * @return {?}
     */
    getDayOfWeekNames(style, force) {
        if (this.lang == 'fa' && !force) {
            return this.JDateAdapter.getDayOfWeekNames(style);
        }
        if (SUPPORTS_INTL_API) {
            /** @type {?} */
            const dtf = new Intl.DateTimeFormat(this.locale, { weekday: style });
            return range(7, (/**
             * @param {?} i
             * @return {?}
             */
            i => this._stripDirectionalityCharacters(dtf.format(new Date(2017, 0, i + 1)))));
        }
        return DEFAULT_DAY_OF_WEEK_NAMES[style];
    }
    /**
     * @param {?} date
     * @param {?=} force
     * @return {?}
     */
    getYearName(date, force) {
        if (this.lang == 'fa' && !force) {
            return this.JDateAdapter.getYearName((/** @type {?} */ (date)));
        }
        if (SUPPORTS_INTL_API) {
            /** @type {?} */
            const dtf = new Intl.DateTimeFormat(this.locale, { year: 'numeric' });
            return this._stripDirectionalityCharacters(dtf.format(date));
        }
        return String(this.getYear(date));
    }
    /**
     * @param {?=} force
     * @return {?}
     */
    getFirstDayOfWeek(force) {
        if (this.lang == 'fa' && !force) {
            return this.JDateAdapter.getFirstDayOfWeek();
        }
        // We can't tell using native JS Date what the first day of the week is, we default to Sunday.
        return 0;
    }
    /**
     * @param {?} date
     * @param {?=} force
     * @return {?}
     */
    getNumDaysInMonth(date, force) {
        if (this.lang == 'fa' && !force) {
            return this.JDateAdapter.getNumDaysInMonth((/** @type {?} */ (date)), 'fa');
        }
        return this.getDate(this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + 1, 0));
    }
    /**
     * @param {?} date
     * @return {?}
     */
    clone(date) {
        if (this.lang == 'fa') {
            return (/** @type {?} */ ((this.JDateAdapter.clone((/** @type {?} */ (date))))));
        }
        return this.createDate(this.getYear(date), this.getMonth(date), this.getDate(date));
    }
    /**
     * @param {?} year
     * @param {?} month
     * @param {?} date
     * @return {?}
     */
    createDate(year, month, date) {
        if (this.lang == 'fa') {
            return (/** @type {?} */ ((this.JDateAdapter.createDate(year, month, date))));
        }
        // Check for invalid month and date (except upper bound on date which we have to check after
        // creating the Date).
        if (month < 0 || month > 11) {
            throw Error(`Invalid month index "${month}". Month index has to be between 0 and 11.`);
        }
        if (date < 1) {
            throw Error(`Invalid date "${date}". Date has to be greater than 0.`);
        }
        /** @type {?} */
        const result = this._createDateWithOverflow(year, month, date);
        // Check that the date wasn't above the upper bound for the month, causing the month to overflow
        if (result.getMonth() != month) {
            throw Error(`Invalid date "${date}" for month with index "${month}".`);
        }
        return result;
    }
    /**
     * @return {?}
     */
    today() {
        if (this.lang == 'fa') {
            return (/** @type {?} */ ((this.JDateAdapter.today())));
        }
        return new Date();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    parse(value) {
        if (this.lang == 'fa') {
            return (/** @type {?} */ (this.JDateAdapter.parse(value, [])));
        }
        // We have no way using the native JS Date to set the parse format or locale, so we ignore these
        // parameters.
        if (typeof value == 'number') {
            return new Date(value);
        }
        return value ? new Date(Date.parse(value)) : null;
    }
    /**
     * @param {?} date
     * @param {?} displayFormat
     * @return {?}
     */
    format(date, displayFormat) {
        if (this.lang == 'fa') {
            return this.JDateAdapter.format((/** @type {?} */ (date)), displayFormat);
        }
        if (!this.isValid(date)) {
            throw Error('NativeDateAdapter: Cannot format invalid date.');
        }
        if (SUPPORTS_INTL_API) {
            if (this.useUtcForDisplay) {
                if (date._d) {
                    date = new Date(Date.UTC(date._d.getFullYear(), date._d.getMonth(), date._d.getDate(), date._d.getHours(), date._d.getMinutes(), date._d.getSeconds(), date._d.getMilliseconds()));
                    displayFormat = extendObject({}, displayFormat, { timeZone: 'utc' });
                }
                else {
                    date = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
                    displayFormat = extendObject({}, displayFormat, { timeZone: 'utc' });
                }
            }
            /** @type {?} */
            const dtf = new Intl.DateTimeFormat(this.locale, displayFormat);
            return this._stripDirectionalityCharacters(dtf.format(date));
        }
        return this._stripDirectionalityCharacters(date.toDateString());
    }
    /**
     * @param {?} date
     * @param {?} years
     * @return {?}
     */
    addCalendarYears(date, years) {
        if (this.lang == 'fa') {
            return (/** @type {?} */ (this.JDateAdapter.addCalendarYears((/** @type {?} */ (date)), years)));
        }
        return this.addCalendarMonths(date, years * 12);
    }
    /**
     * @param {?} date
     * @param {?} months
     * @return {?}
     */
    addCalendarMonths(date, months) {
        if (this.lang == 'fa') {
            return (/** @type {?} */ (this.JDateAdapter.addCalendarMonths((/** @type {?} */ (date)), months)));
        }
        /** @type {?} */
        let newDate = this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + months, this.getDate(date));
        // It's possible to wind up in the wrong month if the original month has more days than the new
        // month. In this case we want to go to the last day of the desired month.
        // Note: the additional + 12 % 12 ensures we end up with a positive number, since JS % doesn't
        // guarantee this.
        if (this.getMonth(newDate) != ((this.getMonth(date) + months) % 12 + 12) % 12) {
            newDate = this._createDateWithOverflow(this.getYear(newDate), this.getMonth(newDate), 0);
        }
        return newDate;
    }
    /**
     * @param {?} date
     * @param {?} days
     * @return {?}
     */
    addCalendarDays(date, days) {
        if (this.lang == 'fa') {
            return (/** @type {?} */ (this.JDateAdapter.addCalendarDays((/** @type {?} */ (date)), days)));
        }
        return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date) + days);
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getISODateString(date) {
        if (this.lang == 'fa') {
            return this.JDateAdapter.getISODateString((/** @type {?} */ (date)));
        }
        return [
            date.getUTCFullYear(),
            this._2digit(date.getUTCMonth() + 1),
            this._2digit(date.getUTCDate())
        ].join('-');
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    isDateInstance(obj) {
        return obj instanceof Date;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    isValid(date) {
        if (date._d) {
            return !isNaN(date._d.getTime());
        }
        return !isNaN(date.getTime());
    }
    /**
     * Creates a date but allows the month and date to overflow.
     * @private
     * @param {?} year
     * @param {?} month
     * @param {?} date
     * @return {?}
     */
    _createDateWithOverflow(year, month, date) {
        /** @type {?} */
        const result = new Date(year, month, date);
        // We need to correct for the fact that JS native Date treats years in range [0, 99] as
        // abbreviations for 19xx.
        if (year >= 0 && year < 100) {
            result.setFullYear(this.getYear(result) - 1900);
        }
        return result;
    }
    /**
     * Pads a number to make it two digits.
     * @private
     * @param {?} n The number to pad.
     * @return {?} The padded number.
     */
    _2digit(n) {
        return ('00' + n).slice(-2);
    }
    /**
     * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while
     * other browsers do not. We remove them to make output consistent and because they interfere with
     * date parsing.
     * @private
     * @param {?} str The string to strip direction characters from.
     * @return {?} The stripped string.
     */
    _stripDirectionalityCharacters(str) {
        return str.replace(/[\u200e\u200f]/g, '');
    }
}
NativeDateAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NativeDateAdapter.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LOCALE_ID,] }] }
];
if (false) {
    /** @type {?} */
    NativeDateAdapter.prototype.lang;
    /** @type {?} */
    NativeDateAdapter.prototype.langSubject;
    /** @type {?} */
    NativeDateAdapter.prototype.JDateAdapter;
    /**
     * Whether to use `timeZone: 'utc'` with `Intl.DateTimeFormat` when formatting dates.
     * Without this `Intl.DateTimeFormat` sometimes chooses the wrong timeZone, which can throw off
     * the result. (e.g. in the en-US locale `new Date(1800, 7, 14).toLocaleDateString()`
     * will produce `'8/13/1800'`.
     * @type {?}
     */
    NativeDateAdapter.prototype.useUtcForDisplay;
}
export class dateFormat {
    /**
     * @param {?} _dateAdapter
     */
    constructor(_dateAdapter) {
        this.parse = {
            dateInput: 'l',
        };
        this.display = {
            dateInput: 'jYYYY/jMM/jDD',
            monthYearLabel: 'jYYYY jMMMM',
            dateA11yLabel: 'jYYYY/jMM/jDD',
            monthYearA11yLabel: 'jYYYY jMMMM'
        };
        this._getChanges = new Subject();
        this._lastChanges = new BehaviorSubject('fa');
        /** @type {?} */
        const dateAdapter = (/** @type {?} */ (_dateAdapter));
        dateAdapter.getLang().subscribe((/**
         * @param {?} v
         * @return {?}
         */
        v => {
            if (v == 'fa') {
                this.parse = {
                    dateInput: 'l',
                };
                this.display = {
                    dateInput: 'jYYYY/jMM/jDD',
                    monthYearLabel: 'jYYYY jMMMM',
                    dateA11yLabel: 'jYYYY/jMM/jDD',
                    monthYearA11yLabel: 'jYYYY jMMMM'
                };
            }
            else {
                this.parse = {
                    dateInput: null,
                };
                this.display = {
                    dateInput: { year: 'numeric', month: 'numeric', day: 'numeric' },
                    monthYearLabel: { year: 'numeric', month: 'short' },
                    dateA11yLabel: { year: 'numeric', month: 'long', day: 'numeric' },
                    monthYearA11yLabel: { year: 'numeric', month: 'long' },
                };
            }
            this._lastChanges.next(v);
            this._getChanges.next(v);
        }), (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
        }), (/**
         * @return {?}
         */
        () => {
        }));
    }
    /**
     * @return {?}
     */
    getChanges() {
        return this._getChanges;
    }
}
if (false) {
    /** @type {?} */
    dateFormat.prototype.parse;
    /** @type {?} */
    dateFormat.prototype.display;
    /** @type {?} */
    dateFormat.prototype._getChanges;
    /** @type {?} */
    dateFormat.prototype._lastChanges;
}
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9tZW50LWRhdGUtYWRhcHRlci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1wZXJzaWFuLWRhdGVwaWNrZXIvIiwic291cmNlcyI6WyJsaWIvbW9tZW50LWRhdGUtYWRhcHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDdEUsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLG1CQUFtQixDQUFDO0FBQzlDLE9BQU8sRUFBQyx1QkFBdUIsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBQzlELE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSxpQkFBaUIsQ0FBQztBQUM3QyxPQUFPLEVBQUMsT0FBTyxFQUFDLE1BQU0sTUFBTSxDQUFDO0FBQzdCLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSxNQUFNLENBQUM7Ozs7OztNQUsvQixpQkFBaUIsR0FBRyxPQUFPLElBQUksSUFBSSxXQUFXOzs7OztNQUk5QyxtQkFBbUIsR0FBRztJQUN4QixNQUFNLEVBQUU7UUFDSixTQUFTLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLFdBQVc7UUFDckYsU0FBUyxFQUFFLFVBQVUsRUFBRSxVQUFVO0tBQ3BDO0lBQ0QsT0FBTyxFQUFFLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUM7SUFDN0YsUUFBUSxFQUFFLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUs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QUNGLDZCQUtFOztJQUVGLGlDQUE0Qjs7SUFDNUIsa0NBQWdEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtJbmplY3QsIEluamVjdGFibGUsIExPQ0FMRV9JRCwgT3B0aW9uYWx9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge0RhdGVBZGFwdGVyfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbCc7XHJcbmltcG9ydCB7SmFsYWxpTW9tZW50RGF0ZUFkYXB0ZXJ9IGZyb20gJy4vamFsYWxpLWRhdGUtYWRhcHRlcic7XHJcbmltcG9ydCB7ZXh0ZW5kT2JqZWN0fSBmcm9tICcuL29iamVjdC1leHRlbmQnO1xyXG5pbXBvcnQge1N1YmplY3R9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQge0JlaGF2aW9yU3ViamVjdH0gZnJvbSAncnhqcyc7XHJcblxyXG5cclxuLy8gVE9ETyhtbWFsZXJiYSk6IFJlbW92ZSB3aGVuIHdlIG5vIGxvbmdlciBzdXBwb3J0IHNhZmFyaSA5LlxyXG4vKiogV2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgSW50bCBBUEkuICovXHJcbmNvbnN0IFNVUFBPUlRTX0lOVExfQVBJID0gdHlwZW9mIEludGwgIT0gJ3VuZGVmaW5lZCc7XHJcblxyXG5cclxuLyoqIFRoZSBkZWZhdWx0IG1vbnRoIG5hbWVzIHRvIHVzZSBpZiBJbnRsIEFQSSBpcyBub3QgYXZhaWxhYmxlLiAqL1xyXG5jb25zdCBERUZBVUxUX01PTlRIX05BTUVTID0ge1xyXG4gICAgJ2xvbmcnOiBbXHJcbiAgICAgICAgJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJyxcclxuICAgICAgICAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlcidcclxuICAgIF0sXHJcbiAgICAnc2hvcnQnOiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ10sXHJcbiAgICAnbmFycm93JzogWydKJywgJ0YnLCAnTScsICdBJywgJ00nLCAnSicsICdKJywgJ0EnLCAnUycsICdPJywgJ04nLCAnRCddXHJcbn07XHJcblxyXG5cclxuLyoqIFRoZSBkZWZhdWx0IGRhdGUgbmFtZXMgdG8gdXNlIGlmIEludGwgQVBJIGlzIG5vdCBhdmFpbGFibGUuICovXHJcbmNvbnN0IERFRkFVTFRfREFURV9OQU1FUyA9IHJhbmdlKDMxLCBpID0+IFN0cmluZyhpICsgMSkpO1xyXG5cclxuXHJcbi8qKiBUaGUgZGVmYXVsdCBkYXkgb2YgdGhlIHdlZWsgbmFtZXMgdG8gdXNlIGlmIEludGwgQVBJIGlzIG5vdCBhdmFpbGFibGUuICovXHJcbmNvbnN0IERFRkFVTFRfREFZX09GX1dFRUtfTkFNRVMgPSB7XHJcbiAgICAnbG9uZyc6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXSxcclxuICAgICdzaG9ydCc6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sXHJcbiAgICAnbmFycm93JzogWydTJywgJ00nLCAnVCcsICdXJywgJ1QnLCAnRicsICdTJ11cclxufTtcclxuXHJcblxyXG4vKiogQ3JlYXRlcyBhbiBhcnJheSBhbmQgZmlsbHMgaXQgd2l0aCB2YWx1ZXMuICovXHJcbmZ1bmN0aW9uIHJhbmdlPFQ+KGxlbmd0aDogbnVtYmVyLCB2YWx1ZUZ1bmN0aW9uOiAoaW5kZXg6IG51bWJlcikgPT4gVCk6IFRbXSB7XHJcbiAgICBjb25zdCB2YWx1ZXNBcnJheSA9IEFycmF5KGxlbmd0aCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFsdWVzQXJyYXlbaV0gPSB2YWx1ZUZ1bmN0aW9uKGkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlc0FycmF5O1xyXG59XHJcblxyXG5cclxuLyoqIEFkYXB0cyB0aGUgbmF0aXZlIEpTIERhdGUgZm9yIHVzZSB3aXRoIGNkay1iYXNlZCBjb21wb25lbnRzIHRoYXQgd29yayB3aXRoIGRhdGVzLiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBOYXRpdmVEYXRlQWRhcHRlciBleHRlbmRzIERhdGVBZGFwdGVyPERhdGU+IHtcclxuICAgIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIEBJbmplY3QoTE9DQUxFX0lEKSBsb2NhbGVJZDogYW55KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICBzdXBlci5zZXRMb2NhbGUobG9jYWxlSWQpO1xyXG4gICAgfVxyXG5cclxuICAgIGxhbmcgPSAnZmEnO1xyXG4gICAgbGFuZ1N1YmplY3QgPSBuZXcgU3ViamVjdCgpO1xyXG4gICAgSkRhdGVBZGFwdGVyID0gbmV3IEphbGFsaU1vbWVudERhdGVBZGFwdGVyKCdmYScpO1xyXG5cclxuICAgIGludmFsaWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdG9Jc284NjAxKGRhdGUpIHtcclxuICAgICAgICByZXR1cm4gJ2hpJztcclxuICAgIH1cclxuXHJcbiAgICBzYW1lRGF0ZShhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHNldExvY2FsZSh2KSB7XHJcbiAgICAgICAgc3VwZXIuc2V0TG9jYWxlKHYpO1xyXG4gICAgICAgIGlmICh0aGlzLmxhbmcgIT0gJ2ZhJykge1xyXG4gICAgICAgICAgICB0aGlzLmxhbmcgPSAnZmEnO1xyXG4gICAgICAgICAgICB0aGlzLmxhbmdTdWJqZWN0Lm5leHQoJ2ZhJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sYW5nID0gJ2VuJztcclxuICAgICAgICAgICAgdGhpcy5sYW5nU3ViamVjdC5uZXh0KCdlbicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXRMYW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxhbmdTdWJqZWN0O1xyXG4gICAgfVxyXG5cclxuICAgIGNoYW5nZUxvY2FsZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5sYW5nICE9ICdmYScpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRMb2NhbGUoJ2ZhJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRMb2NhbGUoJ2VuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0byB1c2UgYHRpbWVab25lOiAndXRjJ2Agd2l0aCBgSW50bC5EYXRlVGltZUZvcm1hdGAgd2hlbiBmb3JtYXR0aW5nIGRhdGVzLlxyXG4gICAgICogV2l0aG91dCB0aGlzIGBJbnRsLkRhdGVUaW1lRm9ybWF0YCBzb21ldGltZXMgY2hvb3NlcyB0aGUgd3JvbmcgdGltZVpvbmUsIHdoaWNoIGNhbiB0aHJvdyBvZmZcclxuICAgICAqIHRoZSByZXN1bHQuIChlLmcuIGluIHRoZSBlbi1VUyBsb2NhbGUgYG5ldyBEYXRlKDE4MDAsIDcsIDE0KS50b0xvY2FsZURhdGVTdHJpbmcoKWBcclxuICAgICAqIHdpbGwgcHJvZHVjZSBgJzgvMTMvMTgwMCdgLlxyXG4gICAgICovXHJcbiAgICB1c2VVdGNGb3JEaXNwbGF5ID0gdHJ1ZTtcclxuXHJcbiAgICBnZXRZZWFyKGRhdGU6IGFueSwgZm9yY2U/KTogbnVtYmVyIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMubGFuZyA9PSAnZmEnICYmICFmb3JjZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5KRGF0ZUFkYXB0ZXIuZ2V0WWVhcihkYXRlIGFzIGFueSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkYXRlLl9kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlLl9kLmdldEZ1bGxZZWFyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKCFkYXRlLmdldEZ1bGxZZWFyKSB7XHJcbiAgICAgICAgICAgIGRlYnVnZ2VyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0TW9udGgoZGF0ZTogYW55LCBmb3JjZT8pOiBudW1iZXIge1xyXG4gICAgICAgIGlmICh0aGlzLmxhbmcgPT0gJ2ZhJyAmJiAhZm9yY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuSkRhdGVBZGFwdGVyLmdldE1vbnRoKGRhdGUgYXMgYW55KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhdGUuX2QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGUuX2QuZ2V0TW9udGgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXREYXRlKGRhdGU6IGFueSwgZm9yY2U/KTogbnVtYmVyIHtcclxuICAgICAgICBpZiAodGhpcy5sYW5nID09ICdmYScgJiYgIWZvcmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkpEYXRlQWRhcHRlci5nZXREYXRlKGRhdGUgYXMgYW55KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhdGUuX2QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGUuX2QuZ2V0RGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0ZS5nZXREYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RGF5T2ZXZWVrKGRhdGU6IERhdGUsIGZvcmNlPyk6IG51bWJlciB7XHJcbiAgICAgICAgaWYgKHRoaXMubGFuZyA9PSAnZmEnICYmICFmb3JjZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5KRGF0ZUFkYXB0ZXIuZ2V0RGF5T2ZXZWVrKGRhdGUgYXMgYW55KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RGF5KCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0TW9udGhOYW1lcyhzdHlsZTogJ2xvbmcnIHwgJ3Nob3J0JyB8ICduYXJyb3cnLCBmb3JjZT8pOiBzdHJpbmdbXSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGFuZyA9PSAnZmEnICYmICFmb3JjZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5KRGF0ZUFkYXB0ZXIuZ2V0TW9udGhOYW1lcyhzdHlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChTVVBQT1JUU19JTlRMX0FQSSkge1xyXG4gICAgICAgICAgICBjb25zdCBkdGYgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh0aGlzLmxvY2FsZSwge21vbnRoOiBzdHlsZX0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2UoMTIsIGkgPT4gdGhpcy5fc3RyaXBEaXJlY3Rpb25hbGl0eUNoYXJhY3RlcnMoZHRmLmZvcm1hdChuZXcgRGF0ZSgyMDE3LCBpLCAxKSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIERFRkFVTFRfTU9OVEhfTkFNRVNbc3R5bGVdO1xyXG4gICAgfVxyXG5cclxuICAgIGdldERhdGVOYW1lcyhmb3JjZT8pOiBzdHJpbmdbXSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGFuZyA9PSAnZmEnICYmICFmb3JjZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5KRGF0ZUFkYXB0ZXIuZ2V0RGF0ZU5hbWVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChTVVBQT1JUU19JTlRMX0FQSSkge1xyXG4gICAgICAgICAgICBjb25zdCBkdGYgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh0aGlzLmxvY2FsZSwge2RheTogJ251bWVyaWMnfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByYW5nZSgzMSwgaSA9PiB0aGlzLl9zdHJpcERpcmVjdGlvbmFsaXR5Q2hhcmFjdGVycyhcclxuICAgICAgICAgICAgICAgIGR0Zi5mb3JtYXQobmV3IERhdGUoMjAxNywgMCwgaSArIDEpKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gREVGQVVMVF9EQVRFX05BTUVTO1xyXG4gICAgfVxyXG5cclxuICAgIGdldERheU9mV2Vla05hbWVzKHN0eWxlOiAnbG9uZycgfCAnc2hvcnQnIHwgJ25hcnJvdycsIGZvcmNlPyk6IHN0cmluZ1tdIHtcclxuICAgICAgICBpZiAodGhpcy5sYW5nID09ICdmYScgJiYgIWZvcmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkpEYXRlQWRhcHRlci5nZXREYXlPZldlZWtOYW1lcyhzdHlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChTVVBQT1JUU19JTlRMX0FQSSkge1xyXG4gICAgICAgICAgICBjb25zdCBkdGYgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh0aGlzLmxvY2FsZSwge3dlZWtkYXk6IHN0eWxlfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByYW5nZSg3LCBpID0+IHRoaXMuX3N0cmlwRGlyZWN0aW9uYWxpdHlDaGFyYWN0ZXJzKFxyXG4gICAgICAgICAgICAgICAgZHRmLmZvcm1hdChuZXcgRGF0ZSgyMDE3LCAwLCBpICsgMSkpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBERUZBVUxUX0RBWV9PRl9XRUVLX05BTUVTW3N0eWxlXTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRZZWFyTmFtZShkYXRlOiBEYXRlLCBmb3JjZT8pOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICh0aGlzLmxhbmcgPT0gJ2ZhJyAmJiAhZm9yY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuSkRhdGVBZGFwdGVyLmdldFllYXJOYW1lKGRhdGUgYXMgYW55KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKFNVUFBPUlRTX0lOVExfQVBJKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGR0ZiA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMubG9jYWxlLCB7eWVhcjogJ251bWVyaWMnfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdHJpcERpcmVjdGlvbmFsaXR5Q2hhcmFjdGVycyhkdGYuZm9ybWF0KGRhdGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZyh0aGlzLmdldFllYXIoZGF0ZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEZpcnN0RGF5T2ZXZWVrKGZvcmNlPyk6IG51bWJlciB7XHJcbiAgICAgICAgaWYgKHRoaXMubGFuZyA9PSAnZmEnICYmICFmb3JjZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5KRGF0ZUFkYXB0ZXIuZ2V0Rmlyc3REYXlPZldlZWsoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2UgY2FuJ3QgdGVsbCB1c2luZyBuYXRpdmUgSlMgRGF0ZSB3aGF0IHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgaXMsIHdlIGRlZmF1bHQgdG8gU3VuZGF5LlxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIGdldE51bURheXNJbk1vbnRoKGRhdGU6IERhdGUsIGZvcmNlPyk6IG51bWJlciB7XHJcbiAgICAgICAgaWYgKHRoaXMubGFuZyA9PSAnZmEnICYmICFmb3JjZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5KRGF0ZUFkYXB0ZXIuZ2V0TnVtRGF5c0luTW9udGgoZGF0ZSBhcyBhbnksICdmYScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRlKHRoaXMuX2NyZWF0ZURhdGVXaXRoT3ZlcmZsb3coXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0WWVhcihkYXRlKSwgdGhpcy5nZXRNb250aChkYXRlKSArIDEsIDApKTtcclxuICAgIH1cclxuXHJcbiAgICBjbG9uZShkYXRlOiBEYXRlKTogRGF0ZSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGFuZyA9PSAnZmEnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5KRGF0ZUFkYXB0ZXIuY2xvbmUoZGF0ZSBhcyBhbnkpKSBhcyBhbnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZURhdGUodGhpcy5nZXRZZWFyKGRhdGUpLCB0aGlzLmdldE1vbnRoKGRhdGUpLCB0aGlzLmdldERhdGUoZGF0ZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZURhdGUoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXRlOiBudW1iZXIpOiBEYXRlIHtcclxuICAgICAgICBpZiAodGhpcy5sYW5nID09ICdmYScpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLkpEYXRlQWRhcHRlci5jcmVhdGVEYXRlKHllYXIsIG1vbnRoLCBkYXRlKSkgYXMgYW55O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVjayBmb3IgaW52YWxpZCBtb250aCBhbmQgZGF0ZSAoZXhjZXB0IHVwcGVyIGJvdW5kIG9uIGRhdGUgd2hpY2ggd2UgaGF2ZSB0byBjaGVjayBhZnRlclxyXG4gICAgICAgIC8vIGNyZWF0aW5nIHRoZSBEYXRlKS5cclxuICAgICAgICBpZiAobW9udGggPCAwIHx8IG1vbnRoID4gMTEpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYEludmFsaWQgbW9udGggaW5kZXggXCIke21vbnRofVwiLiBNb250aCBpbmRleCBoYXMgdG8gYmUgYmV0d2VlbiAwIGFuZCAxMS5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkYXRlIDwgMSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgSW52YWxpZCBkYXRlIFwiJHtkYXRlfVwiLiBEYXRlIGhhcyB0byBiZSBncmVhdGVyIHRoYW4gMC5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2NyZWF0ZURhdGVXaXRoT3ZlcmZsb3coeWVhciwgbW9udGgsIGRhdGUpO1xyXG5cclxuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBkYXRlIHdhc24ndCBhYm92ZSB0aGUgdXBwZXIgYm91bmQgZm9yIHRoZSBtb250aCwgY2F1c2luZyB0aGUgbW9udGggdG8gb3ZlcmZsb3dcclxuICAgICAgICBpZiAocmVzdWx0LmdldE1vbnRoKCkgIT0gbW9udGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYEludmFsaWQgZGF0ZSBcIiR7ZGF0ZX1cIiBmb3IgbW9udGggd2l0aCBpbmRleCBcIiR7bW9udGh9XCIuYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHRvZGF5KCk6IERhdGUge1xyXG4gICAgICAgIGlmICh0aGlzLmxhbmcgPT0gJ2ZhJykge1xyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuSkRhdGVBZGFwdGVyLnRvZGF5KCkpIGFzIGFueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcGFyc2UodmFsdWU6IGFueSk6IERhdGUgfCBudWxsIHtcclxuICAgICAgICBpZiAodGhpcy5sYW5nID09ICdmYScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuSkRhdGVBZGFwdGVyLnBhcnNlKHZhbHVlLCBbXSkgYXMgYW55O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXZSBoYXZlIG5vIHdheSB1c2luZyB0aGUgbmF0aXZlIEpTIERhdGUgdG8gc2V0IHRoZSBwYXJzZSBmb3JtYXQgb3IgbG9jYWxlLCBzbyB3ZSBpZ25vcmUgdGhlc2VcclxuICAgICAgICAvLyBwYXJhbWV0ZXJzLlxyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gbmV3IERhdGUoRGF0ZS5wYXJzZSh2YWx1ZSkpIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBmb3JtYXQoZGF0ZTogYW55LCBkaXNwbGF5Rm9ybWF0OiBPYmplY3QpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICh0aGlzLmxhbmcgPT0gJ2ZhJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5KRGF0ZUFkYXB0ZXIuZm9ybWF0KGRhdGUgYXMgYW55LCBkaXNwbGF5Rm9ybWF0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoZGF0ZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ05hdGl2ZURhdGVBZGFwdGVyOiBDYW5ub3QgZm9ybWF0IGludmFsaWQgZGF0ZS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKFNVUFBPUlRTX0lOVExfQVBJKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZVV0Y0ZvckRpc3BsYXkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRlLl9kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlLl9kLmdldEZ1bGxZZWFyKCksIGRhdGUuX2QuZ2V0TW9udGgoKSwgZGF0ZS5fZC5nZXREYXRlKCksIGRhdGUuX2QuZ2V0SG91cnMoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZS5fZC5nZXRNaW51dGVzKCksIGRhdGUuX2QuZ2V0U2Vjb25kcygpLCBkYXRlLl9kLmdldE1pbGxpc2Vjb25kcygpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheUZvcm1hdCA9IGV4dGVuZE9iamVjdCh7fSwgZGlzcGxheUZvcm1hdCwge3RpbWVab25lOiAndXRjJ30pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSwgZGF0ZS5nZXRIb3VycygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlLmdldE1pbnV0ZXMoKSwgZGF0ZS5nZXRTZWNvbmRzKCksIGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5Rm9ybWF0ID0gZXh0ZW5kT2JqZWN0KHt9LCBkaXNwbGF5Rm9ybWF0LCB7dGltZVpvbmU6ICd1dGMnfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZHRmID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQodGhpcy5sb2NhbGUsIGRpc3BsYXlGb3JtYXQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RyaXBEaXJlY3Rpb25hbGl0eUNoYXJhY3RlcnMoZHRmLmZvcm1hdChkYXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJpcERpcmVjdGlvbmFsaXR5Q2hhcmFjdGVycyhkYXRlLnRvRGF0ZVN0cmluZygpKTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRDYWxlbmRhclllYXJzKGRhdGU6IERhdGUsIHllYXJzOiBudW1iZXIpOiBEYXRlIHtcclxuICAgICAgICBpZiAodGhpcy5sYW5nID09ICdmYScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuSkRhdGVBZGFwdGVyLmFkZENhbGVuZGFyWWVhcnMoZGF0ZSBhcyBhbnksIHllYXJzKSBhcyBhbnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZENhbGVuZGFyTW9udGhzKGRhdGUsIHllYXJzICogMTIpO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZENhbGVuZGFyTW9udGhzKGRhdGU6IERhdGUsIG1vbnRoczogbnVtYmVyKTogRGF0ZSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGFuZyA9PSAnZmEnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkpEYXRlQWRhcHRlci5hZGRDYWxlbmRhck1vbnRocyhkYXRlIGFzIGFueSwgbW9udGhzKSBhcyBhbnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBuZXdEYXRlID0gdGhpcy5fY3JlYXRlRGF0ZVdpdGhPdmVyZmxvdyhcclxuICAgICAgICAgICAgdGhpcy5nZXRZZWFyKGRhdGUpLCB0aGlzLmdldE1vbnRoKGRhdGUpICsgbW9udGhzLCB0aGlzLmdldERhdGUoZGF0ZSkpO1xyXG5cclxuICAgICAgICAvLyBJdCdzIHBvc3NpYmxlIHRvIHdpbmQgdXAgaW4gdGhlIHdyb25nIG1vbnRoIGlmIHRoZSBvcmlnaW5hbCBtb250aCBoYXMgbW9yZSBkYXlzIHRoYW4gdGhlIG5ld1xyXG4gICAgICAgIC8vIG1vbnRoLiBJbiB0aGlzIGNhc2Ugd2Ugd2FudCB0byBnbyB0byB0aGUgbGFzdCBkYXkgb2YgdGhlIGRlc2lyZWQgbW9udGguXHJcbiAgICAgICAgLy8gTm90ZTogdGhlIGFkZGl0aW9uYWwgKyAxMiAlIDEyIGVuc3VyZXMgd2UgZW5kIHVwIHdpdGggYSBwb3NpdGl2ZSBudW1iZXIsIHNpbmNlIEpTICUgZG9lc24ndFxyXG4gICAgICAgIC8vIGd1YXJhbnRlZSB0aGlzLlxyXG4gICAgICAgIGlmICh0aGlzLmdldE1vbnRoKG5ld0RhdGUpICE9ICgodGhpcy5nZXRNb250aChkYXRlKSArIG1vbnRocykgJSAxMiArIDEyKSAlIDEyKSB7XHJcbiAgICAgICAgICAgIG5ld0RhdGUgPSB0aGlzLl9jcmVhdGVEYXRlV2l0aE92ZXJmbG93KHRoaXMuZ2V0WWVhcihuZXdEYXRlKSwgdGhpcy5nZXRNb250aChuZXdEYXRlKSwgMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3RGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRDYWxlbmRhckRheXMoZGF0ZTogRGF0ZSwgZGF5czogbnVtYmVyKTogRGF0ZSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGFuZyA9PSAnZmEnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkpEYXRlQWRhcHRlci5hZGRDYWxlbmRhckRheXMoZGF0ZSBhcyBhbnksIGRheXMpIGFzIGFueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZURhdGVXaXRoT3ZlcmZsb3coXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0WWVhcihkYXRlKSwgdGhpcy5nZXRNb250aChkYXRlKSwgdGhpcy5nZXREYXRlKGRhdGUpICsgZGF5cyk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0SVNPRGF0ZVN0cmluZyhkYXRlOiBEYXRlKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAodGhpcy5sYW5nID09ICdmYScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuSkRhdGVBZGFwdGVyLmdldElTT0RhdGVTdHJpbmcoZGF0ZSBhcyBhbnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBkYXRlLmdldFVUQ0Z1bGxZZWFyKCksXHJcbiAgICAgICAgICAgIHRoaXMuXzJkaWdpdChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSxcclxuICAgICAgICAgICAgdGhpcy5fMmRpZ2l0KGRhdGUuZ2V0VVRDRGF0ZSgpKVxyXG4gICAgICAgIF0uam9pbignLScpO1xyXG4gICAgfVxyXG5cclxuICAgIGlzRGF0ZUluc3RhbmNlKG9iajogYW55KSB7XHJcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIERhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgaXNWYWxpZChkYXRlOiBhbnkpIHtcclxuICAgICAgICBpZiAoZGF0ZS5fZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gIWlzTmFOKGRhdGUuX2QuZ2V0VGltZSgpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAhaXNOYU4oZGF0ZS5nZXRUaW1lKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDcmVhdGVzIGEgZGF0ZSBidXQgYWxsb3dzIHRoZSBtb250aCBhbmQgZGF0ZSB0byBvdmVyZmxvdy4gKi9cclxuICAgIHByaXZhdGUgX2NyZWF0ZURhdGVXaXRoT3ZlcmZsb3coeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXRlOiBudW1iZXIpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF0ZSk7XHJcblxyXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gY29ycmVjdCBmb3IgdGhlIGZhY3QgdGhhdCBKUyBuYXRpdmUgRGF0ZSB0cmVhdHMgeWVhcnMgaW4gcmFuZ2UgWzAsIDk5XSBhc1xyXG4gICAgICAgIC8vIGFiYnJldmlhdGlvbnMgZm9yIDE5eHguXHJcbiAgICAgICAgaWYgKHllYXIgPj0gMCAmJiB5ZWFyIDwgMTAwKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5zZXRGdWxsWWVhcih0aGlzLmdldFllYXIocmVzdWx0KSAtIDE5MDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFkcyBhIG51bWJlciB0byBtYWtlIGl0IHR3byBkaWdpdHMuXHJcbiAgICAgKiBAcGFyYW0gbiBUaGUgbnVtYmVyIHRvIHBhZC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBwYWRkZWQgbnVtYmVyLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF8yZGlnaXQobjogbnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuICgnMDAnICsgbikuc2xpY2UoLTIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RyaXAgb3V0IHVuaWNvZGUgTFRSIGFuZCBSVEwgY2hhcmFjdGVycy4gRWRnZSBhbmQgSUUgaW5zZXJ0IHRoZXNlIGludG8gZm9ybWF0dGVkIGRhdGVzIHdoaWxlXHJcbiAgICAgKiBvdGhlciBicm93c2VycyBkbyBub3QuIFdlIHJlbW92ZSB0aGVtIHRvIG1ha2Ugb3V0cHV0IGNvbnNpc3RlbnQgYW5kIGJlY2F1c2UgdGhleSBpbnRlcmZlcmUgd2l0aFxyXG4gICAgICogZGF0ZSBwYXJzaW5nLlxyXG4gICAgICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIHRvIHN0cmlwIGRpcmVjdGlvbiBjaGFyYWN0ZXJzIGZyb20uXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RyaXBwZWQgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9zdHJpcERpcmVjdGlvbmFsaXR5Q2hhcmFjdGVycyhzdHI6IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvW1xcdTIwMGVcXHUyMDBmXS9nLCAnJyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBkYXRlRm9ybWF0IHtcclxuICAgIHBhcnNlOiBhbnkgPSB7XHJcbiAgICAgICAgZGF0ZUlucHV0OiAnbCcsXHJcbiAgICB9O1xyXG4gICAgZGlzcGxheTogYW55ID0ge1xyXG4gICAgICAgIGRhdGVJbnB1dDogJ2pZWVlZL2pNTS9qREQnLFxyXG4gICAgICAgIG1vbnRoWWVhckxhYmVsOiAnallZWVkgak1NTU0nLFxyXG4gICAgICAgIGRhdGVBMTF5TGFiZWw6ICdqWVlZWS9qTU0vakREJyxcclxuICAgICAgICBtb250aFllYXJBMTF5TGFiZWw6ICdqWVlZWSBqTU1NTSdcclxuICAgIH07XHJcblxyXG4gICAgX2dldENoYW5nZXMgPSBuZXcgU3ViamVjdCgpO1xyXG4gICAgcHVibGljIF9sYXN0Q2hhbmdlcyA9IG5ldyBCZWhhdmlvclN1YmplY3QoJ2ZhJyk7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX2RhdGVBZGFwdGVyOiBEYXRlQWRhcHRlcjxhbnk+KSB7XHJcbiAgICAgICAgY29uc3QgZGF0ZUFkYXB0ZXIgPSBfZGF0ZUFkYXB0ZXIgYXMgYW55O1xyXG4gICAgICAgIGRhdGVBZGFwdGVyLmdldExhbmcoKS5zdWJzY3JpYmUoXHJcbiAgICAgICAgICAgIHYgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHYgPT0gJ2ZhJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2UgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVJbnB1dDogJ2wnLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlSW5wdXQ6ICdqWVlZWS9qTU0vakREJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9udGhZZWFyTGFiZWw6ICdqWVlZWSBqTU1NTScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVBMTF5TGFiZWw6ICdqWVlZWS9qTU0vakREJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9udGhZZWFyQTExeUxhYmVsOiAnallZWVkgak1NTU0nXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZUlucHV0OiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlSW5wdXQ6IHt5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbnVtZXJpYycsIGRheTogJ251bWVyaWMnfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9udGhZZWFyTGFiZWw6IHt5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnc2hvcnQnfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZUExMXlMYWJlbDoge3llYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYyd9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb250aFllYXJBMTF5TGFiZWw6IHt5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZyd9LFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0Q2hhbmdlcy5uZXh0KHYpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0Q2hhbmdlcy5uZXh0KHYpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAoZSkgPT4ge1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGdldENoYW5nZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldENoYW5nZXM7XHJcbiAgICB9XHJcblxyXG59XHJcbiJdfQ==