/**
 * @fileoverview added by tsickle
 * Generated from: lib/datepicker.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ChangeDetectionStrategy, Component, EventEmitter, Inject, InjectionToken, Input, NgZone, Optional, Output, ViewChild, ViewContainerRef, ViewEncapsulation, } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { Overlay, OverlayConfig, } from '@angular/cdk/overlay';
import { ComponentPortal } from '@angular/cdk/portal';
import { Directionality } from '@angular/cdk/bidi';
import { ESCAPE } from '@angular/cdk/keycodes';
import { createMissingDateImplError } from './datepicker-errors';
import { MdCalendar } from './calendar';
import { DateAdapter, MatDialog, } from '@angular/material';
import { first } from 'rxjs/operators';
/**
 * Used to generate a unique ID for each datepicker instance.
 * @type {?}
 */
var datepickerUid = 0;
/**
 * Injection token that determines the scroll handling while the calendar is open.
 * @type {?}
 */
export var MD_DATEPICKER_SCROLL_STRATEGY = new InjectionToken('md-datepicker-scroll-strategy');
/**
 * \@docs-private
 * @param {?} overlay
 * @return {?}
 */
export function MD_DATEPICKER_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
    return (/**
     * @return {?}
     */
    function () { return overlay.scrollStrategies.reposition(); });
}
/**
 * \@docs-private
 * @type {?}
 */
export var MD_DATEPICKER_SCROLL_STRATEGY_PROVIDER = {
    provide: MD_DATEPICKER_SCROLL_STRATEGY, deps: [Overlay], useFactory: MD_DATEPICKER_SCROLL_STRATEGY_PROVIDER_FACTORY,
};
/**
 * Component used as the content for the datepicker dialog and popup. We use this instead of using
 * MdCalendar directly as the content so we can control the initial focus. This also gives us a
 * place to put additional features of the popup that are not part of the calendar itself in the
 * future. (e.g. confirmation buttons).
 * \@docs-private
 * @template D
 */
var MdDatepickerContent = /** @class */ (function () {
    function MdDatepickerContent() {
    }
    /**
     * @return {?}
     */
    MdDatepickerContent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this._calendar._focusActiveCell();
    };
    /**
     * Handles keydown event on datepicker content.
     * @param event The event.
     */
    /**
     * Handles keydown event on datepicker content.
     * @param {?} event The event.
     * @return {?}
     */
    MdDatepickerContent.prototype._handleKeydown = /**
     * Handles keydown event on datepicker content.
     * @param {?} event The event.
     * @return {?}
     */
    function (event) {
        if (event.keyCode === ESCAPE) {
            this.datepicker.close();
            event.preventDefault();
            event.stopPropagation();
        }
    };
    MdDatepickerContent.decorators = [
        { type: Component, args: [{
                    selector: 'md-datepicker-content, mat-datepicker-content',
                    template: "<md-locale-changer>miladi</md-locale-changer>\r\n<md-calendar cdkTrapFocus\r\n             [id]=\"datepicker.id\"\r\n             [type]=\"datepicker.type\"\r\n             [startAt]=\"datepicker.startAt\"\r\n             [startView]=\"datepicker.startView\"\r\n             [minDate]=\"datepicker._minDate\"\r\n             [maxDate]=\"datepicker._maxDate\"\r\n             [dateFilter]=\"datepicker._dateFilter\"\r\n             [selected]=\"datepicker._selected\"\r\n             [subed]=\"datepicker.subed\"\r\n             (selectedChange)=\"datepicker._select($event)\"\r\n             (userSelection)=\"datepicker.close()\">\r\n</md-calendar>\r\n",
                    host: {
                        'class': 'mat-datepicker-content',
                        '[class.mat-datepicker-content-touch]': 'datepicker.touchUi',
                        '(keydown)': '_handleKeydown($event)',
                        '[class.gregorian]': 'datepicker.adapter.lang == "en"',
                    },
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [".gregorian md-calendar * .superSmall{font-family:vazir,sans-serif!important}.mat-calendar-table-header{line-height:14px}.mlabel{text-align:center;margin-top:-40px;margin-bottom:10px;color:rgba(0,0,0,.54);line-height:10px;pointer-events:none}.mlabel span{font-size:10px;color:#989898;padding:0 2px}.mat-datepicker-content{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);direction:rtl;display:block}md-locale-changer{display:block}md-locale-changer>*{margin:20px}md-locale-changer mat-button-toggle-group{margin:16px 16px 0}.mat-calendar{width:296px;height:auto}.mat-datepicker-content-touch{box-shadow:0 0 0 0 rgba(0,0,0,.2),0 0 0 0 rgba(0,0,0,.14),0 0 0 0 rgba(0,0,0,.12);display:block;overflow:auto;margin:-24px}.mat-datepicker-content-touch .mat-calendar{min-width:250px;min-height:312px;max-width:750px;max-height:788px}@media all and (orientation:landscape){.mat-datepicker-content-touch .mat-calendar{width:64vh;height:80vh}}@media all and (orientation:portrait){.mat-datepicker-content-touch .mat-calendar{width:80vw;height:100vw}}"]
                }] }
    ];
    MdDatepickerContent.propDecorators = {
        _calendar: [{ type: ViewChild, args: [MdCalendar, { static: true },] }]
    };
    return MdDatepickerContent;
}());
export { MdDatepickerContent };
if (false) {
    /** @type {?} */
    MdDatepickerContent.prototype.datepicker;
    /** @type {?} */
    MdDatepickerContent.prototype._calendar;
}
// TODO(mmalerba): We use a component instead of a directive here so the user can use implicit
// template reference variables (e.g. #d vs #d="mdDatepicker"). We can change this to a directive if
// angular adds support for `exportAs: '$implicit'` on directives.
/**
 * Component responsible for managing the datepicker popup/dialog.
 * @template D
 */
var MdDatepicker = /** @class */ (function () {
    function MdDatepicker(_dialog, _overlay, _ngZone, _viewContainerRef, _scrollStrategy, _dateAdapter, _dir, _document) {
        this._dialog = _dialog;
        this._overlay = _overlay;
        this._ngZone = _ngZone;
        this._viewContainerRef = _viewContainerRef;
        this._scrollStrategy = _scrollStrategy;
        this._dateAdapter = _dateAdapter;
        this._dir = _dir;
        this._document = _document;
        /**
         * The view that the calendar should start in.
         */
        this.startView = 'month';
        this.type = 'normal';
        /**
         * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather
         * than a popup and elements have more padding to allow for bigger touch targets.
         */
        this.touchUi = false;
        /**
         * Emits new selected date when selected date changes.
         * @deprecated Switch to the `dateChange` and `dateInput` binding on the input element.
         */
        this.selectedChanged = new EventEmitter();
        /**
         * Whether the calendar is open.
         */
        this.opened = false;
        /**
         * The id for the datepicker calendar.
         */
        this.id = "md-datepicker-" + datepickerUid++;
        this._validSelected = null;
        this._validSubed = null;
        /**
         * The element that was focused before the datepicker was opened.
         */
        this._focusedElementBeforeOpen = null;
        if (!this._dateAdapter) {
            throw createMissingDateImplError('DateAdapter');
        }
        this._dateAdapter;
    }
    Object.defineProperty(MdDatepicker.prototype, "subed", {
        //observable
        /** The currently selected date. */
        get: 
        //observable
        /**
         * The currently selected date.
         * @return {?}
         */
        function () {
            return this._validSubed;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._validSubed = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdDatepicker.prototype, "startAt", {
        /** The date to open the calendar to initially. */
        get: /**
         * The date to open the calendar to initially.
         * @return {?}
         */
        function () {
            // If an explicit startAt is set we start there, otherwise we start at whatever the currently
            // selected value is.
            return this._startAt || (this._datepickerInput ? this._datepickerInput.value : null);
        },
        set: /**
         * @param {?} date
         * @return {?}
         */
        function (date) {
            this._startAt = date;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdDatepicker.prototype, "disabled", {
        /** Whether the datepicker pop-up should be disabled. */
        get: /**
         * Whether the datepicker pop-up should be disabled.
         * @return {?}
         */
        function () {
            return this._disabled === undefined ? this._datepickerInput.disabled : this._disabled;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._disabled = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdDatepicker.prototype, "_selected", {
        /** The currently selected date. */
        get: /**
         * The currently selected date.
         * @return {?}
         */
        function () {
            return this._validSelected;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._validSelected = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdDatepicker.prototype, "_minDate", {
        /** The minimum selectable date. */
        get: /**
         * The minimum selectable date.
         * @return {?}
         */
        function () {
            return this._datepickerInput && this._datepickerInput.min;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdDatepicker.prototype, "_maxDate", {
        /** The maximum selectable date. */
        get: /**
         * The maximum selectable date.
         * @return {?}
         */
        function () {
            return this._datepickerInput && this._datepickerInput.max;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdDatepicker.prototype, "_dateFilter", {
        get: /**
         * @return {?}
         */
        function () {
            return this._datepickerInput && this._datepickerInput._dateFilter;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MdDatepicker.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.close();
        if (this._popupRef) {
            this._popupRef.dispose();
        }
        if (this._inputSubscription) {
            this._inputSubscription.unsubscribe();
        }
    };
    /** Selects the given date */
    /**
     * Selects the given date
     * @param {?} date
     * @return {?}
     */
    MdDatepicker.prototype._select = /**
     * Selects the given date
     * @param {?} date
     * @return {?}
     */
    function (date) {
        /** @type {?} */
        var oldValue = this._selected;
        if (((/** @type {?} */ (date)))._d) {
            this._selected = ((/** @type {?} */ (date)))._d;
        }
        else {
            this._selected = date;
        }
        this.selectedChanged.emit(this._selected);
    };
    /**
     * Register an input with this datepicker.
     * @param input The datepicker input to register with this datepicker.
     */
    /**
     * Register an input with this datepicker.
     * @param {?} input The datepicker input to register with this datepicker.
     * @return {?}
     */
    MdDatepicker.prototype._registerInput = /**
     * Register an input with this datepicker.
     * @param {?} input The datepicker input to register with this datepicker.
     * @return {?}
     */
    function (input) {
        var _this = this;
        if (this._datepickerInput) {
            throw Error('An MdDatepicker can only be associated with a single input.');
        }
        this._datepickerInput = input;
        this._inputSubscription = this._datepickerInput._valueChange.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        function (value) { return _this._selected = value; }));
    };
    /** Open the calendar. */
    /**
     * Open the calendar.
     * @return {?}
     */
    MdDatepicker.prototype.open = /**
     * Open the calendar.
     * @return {?}
     */
    function () {
        if (this.opened || this.disabled) {
            return;
        }
        if (!this._datepickerInput) {
            throw Error('Attempted to open an MdDatepicker with no associated input.');
        }
        if (this._document) {
            this._focusedElementBeforeOpen = this._document.activeElement;
        }
        this.touchUi ? this._openAsDialog() : this._openAsPopup();
        this.opened = true;
    };
    /** Close the calendar. */
    /**
     * Close the calendar.
     * @return {?}
     */
    MdDatepicker.prototype.close = /**
     * Close the calendar.
     * @return {?}
     */
    function () {
        if (!this.opened) {
            return;
        }
        if (this._popupRef && this._popupRef.hasAttached()) {
            this._popupRef.detach();
        }
        if (this._dialogRef) {
            this._dialogRef.close();
            this._dialogRef = null;
        }
        if (this._calendarPortal && this._calendarPortal.isAttached) {
            this._calendarPortal.detach();
        }
        if (this._focusedElementBeforeOpen && typeof this._focusedElementBeforeOpen.focus === 'function') {
            this._focusedElementBeforeOpen.focus();
            this._focusedElementBeforeOpen = null;
        }
        this.opened = false;
    };
    /** Open the calendar as a dialog. */
    /**
     * Open the calendar as a dialog.
     * @private
     * @return {?}
     */
    MdDatepicker.prototype._openAsDialog = /**
     * Open the calendar as a dialog.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this._dialogRef = this._dialog.open(MdDatepickerContent, {
            direction: this._dir ? this._dir.value : 'ltr', viewContainerRef: this._viewContainerRef,
        });
        this._dialogRef.afterClosed().subscribe((/**
         * @return {?}
         */
        function () { return _this.close(); }));
        this._dialogRef.componentInstance.datepicker = this;
    };
    /** Open the calendar as a popup. */
    /**
     * Open the calendar as a popup.
     * @private
     * @return {?}
     */
    MdDatepicker.prototype._openAsPopup = /**
     * Open the calendar as a popup.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this._calendarPortal) {
            this._calendarPortal = (/** @type {?} */ (new ComponentPortal(MdDatepickerContent, this._viewContainerRef)));
        }
        if (!this._popupRef) {
            this._createPopup();
        }
        if (!this._popupRef.hasAttached()) {
            /** @type {?} */
            var componentRef = (/** @type {?} */ (this._popupRef.attach(this._calendarPortal)));
            componentRef.instance.datepicker = (/** @type {?} */ (this));
            // Update the position once the calendar has rendered.
            first.call(this._ngZone.onStable).subscribe((/**
             * @return {?}
             */
            function () { return _this._popupRef.updatePosition(); }));
        }
        this._popupRef.backdropClick().subscribe((/**
         * @return {?}
         */
        function () { return _this.close(); }));
    };
    /** Create the popup. */
    /**
     * Create the popup.
     * @private
     * @return {?}
     */
    MdDatepicker.prototype._createPopup = /**
     * Create the popup.
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var overlayState = new OverlayConfig();
        overlayState.positionStrategy = this._createPopupPositionStrategy();
        overlayState.hasBackdrop = true;
        overlayState.backdropClass = 'md-overlay-transparent-backdrop';
        overlayState.direction = this._dir ? this._dir.value : 'ltr';
        overlayState.scrollStrategy = this._scrollStrategy();
        this._popupRef = this._overlay.create(overlayState);
    };
    /** Create the popup PositionStrategy. */
    /**
     * Create the popup PositionStrategy.
     * @private
     * @return {?}
     */
    MdDatepicker.prototype._createPopupPositionStrategy = /**
     * Create the popup PositionStrategy.
     * @private
     * @return {?}
     */
    function () {
        return this._overlay.position()
            .connectedTo(this._datepickerInput.getPopupConnectionElementRef(), {
            originX: 'start', originY: 'bottom'
        }, { overlayX: 'start', overlayY: 'top' })
            .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })
            .withFallbackPosition({ originX: 'end', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' })
            .withFallbackPosition({ originX: 'end', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' });
    };
    MdDatepicker.decorators = [
        { type: Component, args: [{
                    selector: 'md-datepicker, mat-datepicker',
                    template: '',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None
                }] }
    ];
    /** @nocollapse */
    MdDatepicker.ctorParameters = function () { return [
        { type: MatDialog },
        { type: Overlay },
        { type: NgZone },
        { type: ViewContainerRef },
        { type: undefined, decorators: [{ type: Inject, args: [MD_DATEPICKER_SCROLL_STRATEGY,] }] },
        { type: DateAdapter, decorators: [{ type: Optional }] },
        { type: Directionality, decorators: [{ type: Optional }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
    ]; };
    MdDatepicker.propDecorators = {
        subed: [{ type: Input }],
        startAt: [{ type: Input }],
        startView: [{ type: Input }],
        type: [{ type: Input }],
        touchUi: [{ type: Input }],
        disabled: [{ type: Input }],
        selectedChanged: [{ type: Output }]
    };
    return MdDatepicker;
}());
export { MdDatepicker };
if (false) {
    /**
     * @type {?}
     * @private
     */
    MdDatepicker.prototype._startAt;
    /**
     * The view that the calendar should start in.
     * @type {?}
     */
    MdDatepicker.prototype.startView;
    /** @type {?} */
    MdDatepicker.prototype.type;
    /**
     * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather
     * than a popup and elements have more padding to allow for bigger touch targets.
     * @type {?}
     */
    MdDatepicker.prototype.touchUi;
    /**
     * @type {?}
     * @private
     */
    MdDatepicker.prototype._disabled;
    /**
     * Emits new selected date when selected date changes.
     * @deprecated Switch to the `dateChange` and `dateInput` binding on the input element.
     * @type {?}
     */
    MdDatepicker.prototype.selectedChanged;
    /**
     * Whether the calendar is open.
     * @type {?}
     */
    MdDatepicker.prototype.opened;
    /**
     * The id for the datepicker calendar.
     * @type {?}
     */
    MdDatepicker.prototype.id;
    /**
     * @type {?}
     * @private
     */
    MdDatepicker.prototype._validSelected;
    /**
     * @type {?}
     * @private
     */
    MdDatepicker.prototype._validSubed;
    /**
     * A reference to the overlay when the calendar is opened as a popup.
     * @type {?}
     * @private
     */
    MdDatepicker.prototype._popupRef;
    /**
     * A reference to the dialog when the calendar is opened as a dialog.
     * @type {?}
     * @private
     */
    MdDatepicker.prototype._dialogRef;
    /**
     * A portal containing the calendar for this datepicker.
     * @type {?}
     * @private
     */
    MdDatepicker.prototype._calendarPortal;
    /**
     * The input element this datepicker is associated with.
     * @type {?}
     * @private
     */
    MdDatepicker.prototype._datepickerInput;
    /**
     * The element that was focused before the datepicker was opened.
     * @type {?}
     * @private
     */
    MdDatepicker.prototype._focusedElementBeforeOpen;
    /**
     * @type {?}
     * @private
     */
    MdDatepicker.prototype._inputSubscription;
    /** @type {?} */
    MdDatepicker.prototype.adapter;
    /**
     * @type {?}
     * @private
     */
    MdDatepicker.prototype._dialog;
    /**
     * @type {?}
     * @private
     */
    MdDatepicker.prototype._overlay;
    /**
     * @type {?}
     * @private
     */
    MdDatepicker.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    MdDatepicker.prototype._viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    MdDatepicker.prototype._scrollStrategy;
    /** @type {?} */
    MdDatepicker.prototype._dateAdapter;
    /**
     * @type {?}
     * @private
     */
    MdDatepicker.prototype._dir;
    /**
     * @type {?}
     * @private
     */
    MdDatepicker.prototype._document;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXBpY2tlci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1wZXJzaWFuLWRhdGVwaWNrZXIvIiwic291cmNlcyI6WyJsaWIvZGF0ZXBpY2tlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFRQSxPQUFPLEVBRUgsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFFVCxZQUFZLEVBQ1osTUFBTSxFQUNOLGNBQWMsRUFDZCxLQUFLLEVBQ0wsTUFBTSxFQUVOLFFBQVEsRUFDUixNQUFNLEVBQ04sU0FBUyxFQUNULGdCQUFnQixFQUNoQixpQkFBaUIsR0FDcEIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFDLFFBQVEsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBQ3pDLE9BQU8sRUFBQyxxQkFBcUIsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBQzVELE9BQU8sRUFDSCxPQUFPLEVBQWMsYUFBYSxHQUlyQyxNQUFNLHNCQUFzQixDQUFDO0FBQzlCLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQUNwRCxPQUFPLEVBQUMsY0FBYyxFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFDakQsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRzdDLE9BQU8sRUFBQywwQkFBMEIsRUFBQyxNQUFNLHFCQUFxQixDQUFDO0FBQy9ELE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxZQUFZLENBQUM7QUFDdEMsT0FBTyxFQUNILFdBQVcsRUFBRSxTQUFTLEdBQ3pCLE1BQU0sbUJBQW1CLENBQUM7QUFDM0IsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7OztJQUluQyxhQUFhLEdBQUcsQ0FBQzs7Ozs7QUFHckIsTUFBTSxLQUFPLDZCQUE2QixHQUFHLElBQUksY0FBYyxDQUF1QiwrQkFBK0IsQ0FBQzs7Ozs7O0FBR3RILE1BQU0sVUFBVSw4Q0FBOEMsQ0FBQyxPQUFnQjtJQUMzRTs7O0lBQU8sY0FB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QXBHL1QsS0FBSzswQkFRTCxLQUFLOzRCQWFMLEtBQUs7dUJBQ0wsS0FBSzswQkFNTCxLQUFLOzJCQUdMLEtBQUs7a0NBY0wsTUFBTTs7SUE0TFgsbUJBQUM7Q0FBQSxBQW5QRCxJQW1QQztTQTVPWSxZQUFZOzs7Ozs7SUFxQnJCLGdDQUEyQjs7Ozs7SUFHM0IsaUNBQStDOztJQUMvQyw0QkFBNEM7Ozs7OztJQU01QywrQkFBeUI7Ozs7O0lBV3pCLGlDQUEyQjs7Ozs7O0lBTTNCLHVDQUFrRDs7Ozs7SUFHbEQsOEJBQWU7Ozs7O0lBR2YsMEJBQXdDOzs7OztJQWF4QyxzQ0FBd0M7Ozs7O0lBQ3hDLG1DQUFxQzs7Ozs7O0lBaUJyQyxpQ0FBOEI7Ozs7OztJQUc5QixrQ0FBNkM7Ozs7OztJQUc3Qyx1Q0FBaUU7Ozs7OztJQUdqRSx3Q0FBK0M7Ozs7OztJQUcvQyxpREFBNkQ7Ozs7O0lBRTdELDBDQUF5Qzs7SUFFekMsK0JBQWE7Ozs7O0lBRUQsK0JBQTBCOzs7OztJQUFFLGdDQUF5Qjs7Ozs7SUFBRSwrQkFBdUI7Ozs7O0lBQUUseUNBQTJDOzs7OztJQUFFLHVDQUE4RDs7SUFBRSxvQ0FBK0M7Ozs7O0lBQUUsNEJBQXdDOzs7OztJQUFFLGlDQUFvRCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKi9cclxuXHJcbmltcG9ydCB7XHJcbiAgICBBZnRlckNvbnRlbnRJbml0LFxyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXHJcbiAgICBDb21wb25lbnQsXHJcbiAgICBDb21wb25lbnRSZWYsXHJcbiAgICBFdmVudEVtaXR0ZXIsXHJcbiAgICBJbmplY3QsXHJcbiAgICBJbmplY3Rpb25Ub2tlbixcclxuICAgIElucHV0LFxyXG4gICAgTmdab25lLFxyXG4gICAgT25EZXN0cm95LFxyXG4gICAgT3B0aW9uYWwsXHJcbiAgICBPdXRwdXQsXHJcbiAgICBWaWV3Q2hpbGQsXHJcbiAgICBWaWV3Q29udGFpbmVyUmVmLFxyXG4gICAgVmlld0VuY2Fwc3VsYXRpb24sXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7RE9DVU1FTlR9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7Y29lcmNlQm9vbGVhblByb3BlcnR5fSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xyXG5pbXBvcnQge1xyXG4gICAgT3ZlcmxheSwgT3ZlcmxheVJlZiwgT3ZlcmxheUNvbmZpZywgUG9zaXRpb25TdHJhdGVneSwgUmVwb3NpdGlvblNjcm9sbFN0cmF0ZWd5LCAvLyBUaGlzIGltcG9ydCBpcyBvbmx5IHVzZWQgdG8gZGVmaW5lIGEgZ2VuZXJpYyB0eXBlLiBUaGUgY3VycmVudCBUeXBlU2NyaXB0IHZlcnNpb24gaW5jb3JyZWN0bHlcclxuICAgIC8vIGNvbnNpZGVycyBzdWNoIGltcG9ydHMgYXMgdW51c2VkIChodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzE0OTUzKVxyXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXVudXNlZC12YXJpYWJsZVxyXG4gICAgU2Nyb2xsU3RyYXRlZ3ksXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xyXG5pbXBvcnQge0NvbXBvbmVudFBvcnRhbH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BvcnRhbCc7XHJcbmltcG9ydCB7RGlyZWN0aW9uYWxpdHl9IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcclxuaW1wb3J0IHtFU0NBUEV9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XHJcbmltcG9ydCB7TWREYXRlcGlja2VySW5wdXR9IGZyb20gJy4vZGF0ZXBpY2tlci1pbnB1dCc7XHJcbmltcG9ydCB7U3Vic2NyaXB0aW9ufSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHtjcmVhdGVNaXNzaW5nRGF0ZUltcGxFcnJvcn0gZnJvbSAnLi9kYXRlcGlja2VyLWVycm9ycyc7XHJcbmltcG9ydCB7TWRDYWxlbmRhcn0gZnJvbSAnLi9jYWxlbmRhcic7XHJcbmltcG9ydCB7XHJcbiAgICBEYXRlQWRhcHRlciwgTWF0RGlhbG9nLCBNYXREaWFsb2dSZWYsXHJcbn0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwnO1xyXG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcblxyXG4vKiogVXNlZCB0byBnZW5lcmF0ZSBhIHVuaXF1ZSBJRCBmb3IgZWFjaCBkYXRlcGlja2VyIGluc3RhbmNlLiAqL1xyXG5sZXQgZGF0ZXBpY2tlclVpZCA9IDA7XHJcblxyXG4vKiogSW5qZWN0aW9uIHRva2VuIHRoYXQgZGV0ZXJtaW5lcyB0aGUgc2Nyb2xsIGhhbmRsaW5nIHdoaWxlIHRoZSBjYWxlbmRhciBpcyBvcGVuLiAqL1xyXG5leHBvcnQgY29uc3QgTURfREFURVBJQ0tFUl9TQ1JPTExfU1RSQVRFR1kgPSBuZXcgSW5qZWN0aW9uVG9rZW48KCkgPT4gU2Nyb2xsU3RyYXRlZ3k+KCdtZC1kYXRlcGlja2VyLXNjcm9sbC1zdHJhdGVneScpO1xyXG5cclxuLyoqIEBkb2NzLXByaXZhdGUgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIE1EX0RBVEVQSUNLRVJfU0NST0xMX1NUUkFURUdZX1BST1ZJREVSX0ZBQ1RPUlkob3ZlcmxheTogT3ZlcmxheSk6ICgpID0+IFJlcG9zaXRpb25TY3JvbGxTdHJhdGVneSB7XHJcbiAgICByZXR1cm4gKCkgPT4gb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLnJlcG9zaXRpb24oKTtcclxufVxyXG5cclxuLyoqIEBkb2NzLXByaXZhdGUgKi9cclxuZXhwb3J0IGNvbnN0IE1EX0RBVEVQSUNLRVJfU0NST0xMX1NUUkFURUdZX1BST1ZJREVSID0ge1xyXG4gICAgcHJvdmlkZTogTURfREFURVBJQ0tFUl9TQ1JPTExfU1RSQVRFR1ksIGRlcHM6IFtPdmVybGF5XSwgdXNlRmFjdG9yeTogTURfREFURVBJQ0tFUl9TQ1JPTExfU1RSQVRFR1lfUFJPVklERVJfRkFDVE9SWSxcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQ29tcG9uZW50IHVzZWQgYXMgdGhlIGNvbnRlbnQgZm9yIHRoZSBkYXRlcGlja2VyIGRpYWxvZyBhbmQgcG9wdXAuIFdlIHVzZSB0aGlzIGluc3RlYWQgb2YgdXNpbmdcclxuICogTWRDYWxlbmRhciBkaXJlY3RseSBhcyB0aGUgY29udGVudCBzbyB3ZSBjYW4gY29udHJvbCB0aGUgaW5pdGlhbCBmb2N1cy4gVGhpcyBhbHNvIGdpdmVzIHVzIGFcclxuICogcGxhY2UgdG8gcHV0IGFkZGl0aW9uYWwgZmVhdHVyZXMgb2YgdGhlIHBvcHVwIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIHRoZSBjYWxlbmRhciBpdHNlbGYgaW4gdGhlXHJcbiAqIGZ1dHVyZS4gKGUuZy4gY29uZmlybWF0aW9uIGJ1dHRvbnMpLlxyXG4gKiBAZG9jcy1wcml2YXRlXHJcbiAqL1xyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAnbWQtZGF0ZXBpY2tlci1jb250ZW50LCBtYXQtZGF0ZXBpY2tlci1jb250ZW50JyxcclxuICAgIHRlbXBsYXRlVXJsOiAnZGF0ZXBpY2tlci1jb250ZW50Lmh0bWwnLFxyXG4gICAgc3R5bGVVcmxzOiBbJ2RhdGVwaWNrZXItY29udGVudC5zY3NzJ10sXHJcbiAgICBob3N0OiB7XHJcbiAgICAgICAgJ2NsYXNzJzogJ21hdC1kYXRlcGlja2VyLWNvbnRlbnQnLFxyXG4gICAgICAgICdbY2xhc3MubWF0LWRhdGVwaWNrZXItY29udGVudC10b3VjaF0nOiAnZGF0ZXBpY2tlci50b3VjaFVpJyxcclxuICAgICAgICAnKGtleWRvd24pJzogJ19oYW5kbGVLZXlkb3duKCRldmVudCknLFxyXG4gICAgICAgICdbY2xhc3MuZ3JlZ29yaWFuXSc6ICdkYXRlcGlja2VyLmFkYXB0ZXIubGFuZyA9PSBcImVuXCInLFxyXG4gICAgfSxcclxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxufSlcclxuZXhwb3J0IGNsYXNzIE1kRGF0ZXBpY2tlckNvbnRlbnQ8RD4gaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcclxuICAgIGRhdGVwaWNrZXI6IE1kRGF0ZXBpY2tlcjxEPjtcclxuICAgIEBWaWV3Q2hpbGQoTWRDYWxlbmRhciwge3N0YXRpYzp0cnVlfSkgX2NhbGVuZGFyOiBNZENhbGVuZGFyPEQ+O1xyXG5cclxuXHJcbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XHJcblxyXG4gICAgICAgIHRoaXMuX2NhbGVuZGFyLl9mb2N1c0FjdGl2ZUNlbGwoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXMga2V5ZG93biBldmVudCBvbiBkYXRlcGlja2VyIGNvbnRlbnQuXHJcbiAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBfaGFuZGxlS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xyXG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBFU0NBUEUpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRlcGlja2VyLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8vIFRPRE8obW1hbGVyYmEpOiBXZSB1c2UgYSBjb21wb25lbnQgaW5zdGVhZCBvZiBhIGRpcmVjdGl2ZSBoZXJlIHNvIHRoZSB1c2VyIGNhbiB1c2UgaW1wbGljaXRcclxuLy8gdGVtcGxhdGUgcmVmZXJlbmNlIHZhcmlhYmxlcyAoZS5nLiAjZCB2cyAjZD1cIm1kRGF0ZXBpY2tlclwiKS4gV2UgY2FuIGNoYW5nZSB0aGlzIHRvIGEgZGlyZWN0aXZlIGlmXHJcbi8vIGFuZ3VsYXIgYWRkcyBzdXBwb3J0IGZvciBgZXhwb3J0QXM6ICckaW1wbGljaXQnYCBvbiBkaXJlY3RpdmVzLlxyXG4vKiogQ29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBtYW5hZ2luZyB0aGUgZGF0ZXBpY2tlciBwb3B1cC9kaWFsb2cuICovXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICdtZC1kYXRlcGlja2VyLCBtYXQtZGF0ZXBpY2tlcicsXHJcbiAgICB0ZW1wbGF0ZTogJycsXHJcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcblxyXG59KVxyXG5leHBvcnQgY2xhc3MgTWREYXRlcGlja2VyPEQ+IGltcGxlbWVudHMgT25EZXN0cm95IHtcclxuICAgIC8vb2JzZXJ2YWJsZVxyXG4gICAgLyoqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZGF0ZS4gKi9cclxuICAgIEBJbnB1dCgpIGdldCBzdWJlZCgpOiBEIHwgbnVsbCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkU3ViZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IHN1YmVkKHZhbHVlOiBEIHwgbnVsbCkge1xyXG4gICAgICAgIHRoaXMuX3ZhbGlkU3ViZWQgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKiBUaGUgZGF0ZSB0byBvcGVuIHRoZSBjYWxlbmRhciB0byBpbml0aWFsbHkuICovXHJcbiAgICBASW5wdXQoKSBnZXQgc3RhcnRBdCgpOiBEIHwgbnVsbCB7XHJcbiAgICAgICAgLy8gSWYgYW4gZXhwbGljaXQgc3RhcnRBdCBpcyBzZXQgd2Ugc3RhcnQgdGhlcmUsIG90aGVyd2lzZSB3ZSBzdGFydCBhdCB3aGF0ZXZlciB0aGUgY3VycmVudGx5XHJcbiAgICAgICAgLy8gc2VsZWN0ZWQgdmFsdWUgaXMuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0QXQgfHwgKHRoaXMuX2RhdGVwaWNrZXJJbnB1dCA/IHRoaXMuX2RhdGVwaWNrZXJJbnB1dC52YWx1ZSA6IG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBzdGFydEF0KGRhdGU6IEQgfCBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRBdCA9IGRhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfc3RhcnRBdDogRCB8IG51bGw7XHJcblxyXG4gICAgLyoqIFRoZSB2aWV3IHRoYXQgdGhlIGNhbGVuZGFyIHNob3VsZCBzdGFydCBpbi4gKi9cclxuICAgIEBJbnB1dCgpIHN0YXJ0VmlldzogJ21vbnRoJyB8ICd5ZWFyJyA9ICdtb250aCc7XHJcbiAgICBASW5wdXQoKSB0eXBlOiAnbm9ybWFsJyB8ICd3aWRlJyA9ICdub3JtYWwnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgY2FsZW5kYXIgVUkgaXMgaW4gdG91Y2ggbW9kZS4gSW4gdG91Y2ggbW9kZSB0aGUgY2FsZW5kYXIgb3BlbnMgaW4gYSBkaWFsb2cgcmF0aGVyXHJcbiAgICAgKiB0aGFuIGEgcG9wdXAgYW5kIGVsZW1lbnRzIGhhdmUgbW9yZSBwYWRkaW5nIHRvIGFsbG93IGZvciBiaWdnZXIgdG91Y2ggdGFyZ2V0cy5cclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgdG91Y2hVaSA9IGZhbHNlO1xyXG5cclxuICAgIC8qKiBXaGV0aGVyIHRoZSBkYXRlcGlja2VyIHBvcC11cCBzaG91bGQgYmUgZGlzYWJsZWQuICovXHJcbiAgICBASW5wdXQoKSBnZXQgZGlzYWJsZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkID09PSB1bmRlZmluZWQgPyB0aGlzLl9kYXRlcGlja2VySW5wdXQuZGlzYWJsZWQgOiB0aGlzLl9kaXNhYmxlZDtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgZGlzYWJsZWQodmFsdWU6IGFueSkge1xyXG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9kaXNhYmxlZDogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVtaXRzIG5ldyBzZWxlY3RlZCBkYXRlIHdoZW4gc2VsZWN0ZWQgZGF0ZSBjaGFuZ2VzLlxyXG4gICAgICogQGRlcHJlY2F0ZWQgU3dpdGNoIHRvIHRoZSBgZGF0ZUNoYW5nZWAgYW5kIGBkYXRlSW5wdXRgIGJpbmRpbmcgb24gdGhlIGlucHV0IGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBzZWxlY3RlZENoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPEQ+KCk7XHJcblxyXG4gICAgLyoqIFdoZXRoZXIgdGhlIGNhbGVuZGFyIGlzIG9wZW4uICovXHJcbiAgICBvcGVuZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvKiogVGhlIGlkIGZvciB0aGUgZGF0ZXBpY2tlciBjYWxlbmRhci4gKi9cclxuICAgIGlkID0gYG1kLWRhdGVwaWNrZXItJHtkYXRlcGlja2VyVWlkKyt9YDtcclxuXHJcbiAgICAvKiogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBkYXRlLiAqL1xyXG4gICAgZ2V0IF9zZWxlY3RlZCgpOiBEIHwgbnVsbCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkU2VsZWN0ZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IF9zZWxlY3RlZCh2YWx1ZTogRCB8IG51bGwpIHtcclxuICAgICAgICB0aGlzLl92YWxpZFNlbGVjdGVkID0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICBwcml2YXRlIF92YWxpZFNlbGVjdGVkOiBEIHwgbnVsbCA9IG51bGw7XHJcbiAgICBwcml2YXRlIF92YWxpZFN1YmVkOiBEIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgLyoqIFRoZSBtaW5pbXVtIHNlbGVjdGFibGUgZGF0ZS4gKi9cclxuICAgIGdldCBfbWluRGF0ZSgpOiBEIHwgbnVsbCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGVwaWNrZXJJbnB1dCAmJiB0aGlzLl9kYXRlcGlja2VySW5wdXQubWluO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgbWF4aW11bSBzZWxlY3RhYmxlIGRhdGUuICovXHJcbiAgICBnZXQgX21heERhdGUoKTogRCB8IG51bGwge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRlcGlja2VySW5wdXQgJiYgdGhpcy5fZGF0ZXBpY2tlcklucHV0Lm1heDtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgX2RhdGVGaWx0ZXIoKTogKGRhdGU6IEQgfCBudWxsKSA9PiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0ZXBpY2tlcklucHV0ICYmIHRoaXMuX2RhdGVwaWNrZXJJbnB1dC5fZGF0ZUZpbHRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQSByZWZlcmVuY2UgdG8gdGhlIG92ZXJsYXkgd2hlbiB0aGUgY2FsZW5kYXIgaXMgb3BlbmVkIGFzIGEgcG9wdXAuICovXHJcbiAgICBwcml2YXRlIF9wb3B1cFJlZjogT3ZlcmxheVJlZjtcclxuXHJcbiAgICAvKiogQSByZWZlcmVuY2UgdG8gdGhlIGRpYWxvZyB3aGVuIHRoZSBjYWxlbmRhciBpcyBvcGVuZWQgYXMgYSBkaWFsb2cuICovXHJcbiAgICBwcml2YXRlIF9kaWFsb2dSZWY6IE1hdERpYWxvZ1JlZjxhbnk+IHwgbnVsbDtcclxuXHJcbiAgICAvKiogQSBwb3J0YWwgY29udGFpbmluZyB0aGUgY2FsZW5kYXIgZm9yIHRoaXMgZGF0ZXBpY2tlci4gKi9cclxuICAgIHByaXZhdGUgX2NhbGVuZGFyUG9ydGFsOiBDb21wb25lbnRQb3J0YWw8TWREYXRlcGlja2VyQ29udGVudDxEPj47XHJcblxyXG4gICAgLyoqIFRoZSBpbnB1dCBlbGVtZW50IHRoaXMgZGF0ZXBpY2tlciBpcyBhc3NvY2lhdGVkIHdpdGguICovXHJcbiAgICBwcml2YXRlIF9kYXRlcGlja2VySW5wdXQ6IE1kRGF0ZXBpY2tlcklucHV0PEQ+O1xyXG5cclxuICAgIC8qKiBUaGUgZWxlbWVudCB0aGF0IHdhcyBmb2N1c2VkIGJlZm9yZSB0aGUgZGF0ZXBpY2tlciB3YXMgb3BlbmVkLiAqL1xyXG4gICAgcHJpdmF0ZSBfZm9jdXNlZEVsZW1lbnRCZWZvcmVPcGVuOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgIHByaXZhdGUgX2lucHV0U3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XHJcblxyXG4gICAgYWRhcHRlcjogYW55O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2RpYWxvZzogTWF0RGlhbG9nLCBwcml2YXRlIF9vdmVybGF5OiBPdmVybGF5LCBwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSwgcHJpdmF0ZSBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZiwgQEluamVjdChNRF9EQVRFUElDS0VSX1NDUk9MTF9TVFJBVEVHWSkgcHJpdmF0ZSBfc2Nyb2xsU3RyYXRlZ3ksIEBPcHRpb25hbCgpIHB1YmxpYyBfZGF0ZUFkYXB0ZXI6IERhdGVBZGFwdGVyPEQ+LCBAT3B0aW9uYWwoKSBwcml2YXRlIF9kaXI6IERpcmVjdGlvbmFsaXR5LCBAT3B0aW9uYWwoKSBASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIF9kb2N1bWVudDogYW55KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9kYXRlQWRhcHRlcikge1xyXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVNaXNzaW5nRGF0ZUltcGxFcnJvcignRGF0ZUFkYXB0ZXInKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLl9wb3B1cFJlZikge1xyXG4gICAgICAgICAgICB0aGlzLl9wb3B1cFJlZi5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9pbnB1dFN1YnNjcmlwdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9pbnB1dFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogU2VsZWN0cyB0aGUgZ2l2ZW4gZGF0ZSAqL1xyXG4gICAgX3NlbGVjdChkYXRlOiBEKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl9zZWxlY3RlZDtcclxuICAgICAgICBpZiAoKGRhdGUgYXMgYW55KS5fZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IChkYXRlIGFzIGFueSkuX2Q7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkID0gZGF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZWQuZW1pdCh0aGlzLl9zZWxlY3RlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciBhbiBpbnB1dCB3aXRoIHRoaXMgZGF0ZXBpY2tlci5cclxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgZGF0ZXBpY2tlciBpbnB1dCB0byByZWdpc3RlciB3aXRoIHRoaXMgZGF0ZXBpY2tlci5cclxuICAgICAqL1xyXG4gICAgX3JlZ2lzdGVySW5wdXQoaW5wdXQ6IE1kRGF0ZXBpY2tlcklucHV0PEQ+KTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RhdGVwaWNrZXJJbnB1dCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignQW4gTWREYXRlcGlja2VyIGNhbiBvbmx5IGJlIGFzc29jaWF0ZWQgd2l0aCBhIHNpbmdsZSBpbnB1dC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZGF0ZXBpY2tlcklucHV0ID0gaW5wdXQ7XHJcbiAgICAgICAgdGhpcy5faW5wdXRTdWJzY3JpcHRpb24gPSB0aGlzLl9kYXRlcGlja2VySW5wdXQuX3ZhbHVlQ2hhbmdlLnN1YnNjcmliZSgodmFsdWU6IEQgfCBudWxsKSA9PiB0aGlzLl9zZWxlY3RlZCA9IHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogT3BlbiB0aGUgY2FsZW5kYXIuICovXHJcbiAgICBvcGVuKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLm9wZW5lZCB8fCB0aGlzLmRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9kYXRlcGlja2VySW5wdXQpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0F0dGVtcHRlZCB0byBvcGVuIGFuIE1kRGF0ZXBpY2tlciB3aXRoIG5vIGFzc29jaWF0ZWQgaW5wdXQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9kb2N1bWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLl9mb2N1c2VkRWxlbWVudEJlZm9yZU9wZW4gPSB0aGlzLl9kb2N1bWVudC5hY3RpdmVFbGVtZW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy50b3VjaFVpID8gdGhpcy5fb3BlbkFzRGlhbG9nKCkgOiB0aGlzLl9vcGVuQXNQb3B1cCgpO1xyXG4gICAgICAgIHRoaXMub3BlbmVkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ2xvc2UgdGhlIGNhbGVuZGFyLiAqL1xyXG4gICAgY2xvc2UoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLm9wZW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9wb3B1cFJlZiAmJiB0aGlzLl9wb3B1cFJlZi5oYXNBdHRhY2hlZCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvcHVwUmVmLmRldGFjaCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZGlhbG9nUmVmKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpYWxvZ1JlZi5jbG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9kaWFsb2dSZWYgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fY2FsZW5kYXJQb3J0YWwgJiYgdGhpcy5fY2FsZW5kYXJQb3J0YWwuaXNBdHRhY2hlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jYWxlbmRhclBvcnRhbC5kZXRhY2goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZvY3VzZWRFbGVtZW50QmVmb3JlT3BlbiAmJiB0eXBlb2YgdGhpcy5fZm9jdXNlZEVsZW1lbnRCZWZvcmVPcGVuLmZvY3VzID09PSAnZnVuY3Rpb24nKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9mb2N1c2VkRWxlbWVudEJlZm9yZU9wZW4uZm9jdXMoKTtcclxuICAgICAgICAgICAgdGhpcy5fZm9jdXNlZEVsZW1lbnRCZWZvcmVPcGVuID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMub3BlbmVkID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIE9wZW4gdGhlIGNhbGVuZGFyIGFzIGEgZGlhbG9nLiAqL1xyXG4gICAgcHJpdmF0ZSBfb3BlbkFzRGlhbG9nKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2RpYWxvZ1JlZiA9IHRoaXMuX2RpYWxvZy5vcGVuKE1kRGF0ZXBpY2tlckNvbnRlbnQsIHtcclxuICAgICAgICAgICAgZGlyZWN0aW9uOiB0aGlzLl9kaXIgPyB0aGlzLl9kaXIudmFsdWUgOiAnbHRyJywgdmlld0NvbnRhaW5lclJlZjogdGhpcy5fdmlld0NvbnRhaW5lclJlZixcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9kaWFsb2dSZWYuYWZ0ZXJDbG9zZWQoKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jbG9zZSgpKTtcclxuICAgICAgICB0aGlzLl9kaWFsb2dSZWYuY29tcG9uZW50SW5zdGFuY2UuZGF0ZXBpY2tlciA9IHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIE9wZW4gdGhlIGNhbGVuZGFyIGFzIGEgcG9wdXAuICovXHJcbiAgICBwcml2YXRlIF9vcGVuQXNQb3B1cCgpOiB2b2lkIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2NhbGVuZGFyUG9ydGFsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbGVuZGFyUG9ydGFsID0gbmV3IENvbXBvbmVudFBvcnRhbChNZERhdGVwaWNrZXJDb250ZW50LCB0aGlzLl92aWV3Q29udGFpbmVyUmVmKSBhcyBhbnk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRoaXMuX3BvcHVwUmVmKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRoaXMuX3BvcHVwUmVmLmhhc0F0dGFjaGVkKCkpIHtcclxuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50UmVmOiBDb21wb25lbnRSZWY8TWREYXRlcGlja2VyQ29udGVudDxEPj4gPSB0aGlzLl9wb3B1cFJlZi5hdHRhY2godGhpcy5fY2FsZW5kYXJQb3J0YWwpIGFzIGFueTtcclxuICAgICAgICAgICAgY29tcG9uZW50UmVmLmluc3RhbmNlLmRhdGVwaWNrZXIgPSB0aGlzIGFzIGFueTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcG9zaXRpb24gb25jZSB0aGUgY2FsZW5kYXIgaGFzIHJlbmRlcmVkLlxyXG4gICAgICAgICAgICBmaXJzdC5jYWxsKHRoaXMuX25nWm9uZS5vblN0YWJsZSkuc3Vic2NyaWJlKCgpID0+IHRoaXMuX3BvcHVwUmVmLnVwZGF0ZVBvc2l0aW9uKCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fcG9wdXBSZWYuYmFja2Ryb3BDbGljaygpLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNsb3NlKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDcmVhdGUgdGhlIHBvcHVwLiAqL1xyXG4gICAgcHJpdmF0ZSBfY3JlYXRlUG9wdXAoKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3Qgb3ZlcmxheVN0YXRlID0gbmV3IE92ZXJsYXlDb25maWcoKTtcclxuICAgICAgICBvdmVybGF5U3RhdGUucG9zaXRpb25TdHJhdGVneSA9IHRoaXMuX2NyZWF0ZVBvcHVwUG9zaXRpb25TdHJhdGVneSgpO1xyXG4gICAgICAgIG92ZXJsYXlTdGF0ZS5oYXNCYWNrZHJvcCA9IHRydWU7XHJcbiAgICAgICAgb3ZlcmxheVN0YXRlLmJhY2tkcm9wQ2xhc3MgPSAnbWQtb3ZlcmxheS10cmFuc3BhcmVudC1iYWNrZHJvcCc7XHJcbiAgICAgICAgb3ZlcmxheVN0YXRlLmRpcmVjdGlvbiA9IHRoaXMuX2RpciA/IHRoaXMuX2Rpci52YWx1ZSA6ICdsdHInO1xyXG4gICAgICAgIG92ZXJsYXlTdGF0ZS5zY3JvbGxTdHJhdGVneSA9IHRoaXMuX3Njcm9sbFN0cmF0ZWd5KCk7XHJcblxyXG4gICAgICAgIHRoaXMuX3BvcHVwUmVmID0gdGhpcy5fb3ZlcmxheS5jcmVhdGUob3ZlcmxheVN0YXRlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ3JlYXRlIHRoZSBwb3B1cCBQb3NpdGlvblN0cmF0ZWd5LiAqL1xyXG4gICAgcHJpdmF0ZSBfY3JlYXRlUG9wdXBQb3NpdGlvblN0cmF0ZWd5KCk6IFBvc2l0aW9uU3RyYXRlZ3kge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKClcclxuICAgICAgICAgICAgLmNvbm5lY3RlZFRvKHRoaXMuX2RhdGVwaWNrZXJJbnB1dC5nZXRQb3B1cENvbm5lY3Rpb25FbGVtZW50UmVmKCksIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpblg6ICdzdGFydCcsIG9yaWdpblk6ICdib3R0b20nXHJcbiAgICAgICAgICAgIH0sIHtvdmVybGF5WDogJ3N0YXJ0Jywgb3ZlcmxheVk6ICd0b3AnfSlcclxuICAgICAgICAgICAgLndpdGhGYWxsYmFja1Bvc2l0aW9uKHtvcmlnaW5YOiAnc3RhcnQnLCBvcmlnaW5ZOiAndG9wJ30sIHtvdmVybGF5WDogJ3N0YXJ0Jywgb3ZlcmxheVk6ICdib3R0b20nfSlcclxuICAgICAgICAgICAgLndpdGhGYWxsYmFja1Bvc2l0aW9uKHtvcmlnaW5YOiAnZW5kJywgb3JpZ2luWTogJ2JvdHRvbSd9LCB7b3ZlcmxheVg6ICdlbmQnLCBvdmVybGF5WTogJ3RvcCd9KVxyXG4gICAgICAgICAgICAud2l0aEZhbGxiYWNrUG9zaXRpb24oe29yaWdpblg6ICdlbmQnLCBvcmlnaW5ZOiAndG9wJ30sIHtvdmVybGF5WDogJ2VuZCcsIG92ZXJsYXlZOiAnYm90dG9tJ30pO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==